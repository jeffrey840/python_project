


Here are the organized questions and their respective options:

1. **Which of the following statements are true?**
   - A. Every recursive method must have a base case or a stopping condition.
   - B. Every recursive call reduces the original problem, bringing it increasingly closer to a base case until it becomes that case.
   - C. Infinite recursion can occur if recursion does not reduce the problem in a manner that allows it to eventually converge into the base case.
   - D. Every recursive method must have a return value.
   - E. A recursive method is invoked differently from a non-recursive method.

2. **Fill in the code to complete the following method for computing factorial.**
   - `/* Return the factorial for a specified index */ public static long factorial(int n) { if (n == 0) // Base case return 1; else return _____________; // Recursive call }`
   - Options: `n * factorial(n - 1)`, `factorial(n - 1) * n`

3. **What are the base cases in the following recursive method?**
   - `public static void xMethod(int n) { if (n > 0) { System.out.print(n % 10); xMethod(n / 10); } }`
   - Option: `n <= 0`

4. **Analyze the following recursive method.**
   - `public static long factorial(int n) { return n * factorial(n - 1); }`
   - Option: The method runs infinitely and causes a StackOverflowError.

5. **How many times is the factorial method in Listing 18.1 invoked for factorial(5)?**
   - Option: 6

6. **Which of the following statements are true?**
   - A. The Fibonacci series begins with 0 and 1, and each subsequent number is the sum of the preceding two numbers in the series.
   - B. The Fibonacci series begins with 1 and 1, and each subsequent number is the sum of the preceding two numbers in the series.
   - C. The Fibonacci series begins with 1 and 2, and each subsequent number is the sum of the preceding two numbers in the series.
   - D. The Fibonacci series begins with 2 and 3, and each subsequent number is the sum of the preceding two numbers in the series.

7. **How many times is the fib method in Listing 18.2 invoked for fib(5)?**
   - Option: 15

8. **Fill in the code to complete the following method for computing a Fibonacci number.**
   - `public static long fib(long index) { if (index == 0) // Base case return 0; else if (index == 1) // Base case return 1; else // Reduction and recursive calls return __________________; }`
   - Options: `fib(index - 1) + fib(index - 2)`, `fib(index - 2) + fib(index - 1)`

9. **In the following method, what is the base case?**
   - `static int xMethod(int n) { if (n == 1) return 1; else return n + xMethod(n - 1); }`
   - Option: `n is 1`

10. **What is the return value for xMethod(4) after calling the following method?**
    - `static int xMethod(int n) { if (n == 1) return 1; else return n + xMethod(n - 1); }`
    - Option: 10 (Explanation: 4 + 3 + 2 + 1 = 10)

11. **Fill in the code to complete the following method for checking whether a string is a palindrome.**
    - `public static boolean isPalindrome(String s) { if (s.length() <= 1) // Base case return true; else if _____________________________ return false; else return isPalindrome(s.substring(1, s.length() - 1)); }`
    - Option: `(s.charAt(0) != s.charAt(s.length() - 1)) // Base case`

12. **Analyze the following code:**
    - `public class Test { public static void main(String[] args) { int[] x = {1, 2, 3, 4, 5}; xMethod(x, 5); } public static void xMethod(int[] x, int length) { System.out.print(" " + x[length - 1]); xMethod(x, length - 1); } }`
    - Option: The program displays 5 4 3 2 1 and then raises an ArrayIndexOutOfBoundsException.

13. **Fill in the code to complete the following method for checking whether a string is a palindrome.**
    - `public static boolean isPalindrome(String s) { return isPalindrome(s, 0, s.length() -

1); } public static boolean isPalindrome(String s, int low, int high) { if (high <= low) // Base case return true; else if (s.charAt(low) != s.charAt(high)) // Base case return false; else return _______________________________; }`
    - Option: `isPalindrome(s, low + 1, high - 1)`

14. **Fill in the code to complete the following method for sorting a list.**
    - `public static void sort(double[] list) { ___________________________; } public static void sort(double[] list, int high) { if (high > 1) { // Find the largest number and its index int indexOfMax = 0; double max = list[0]; for (int i = 1; i <= high; i++) { if (list[i] > max) { max = list[i]; indexOfMax = i; } } // Swap the largest with the last number in the list list[indexOfMax] = list[high]; list[high] = max; // Sort the remaining list sort(list, high - 1); } }`
    - Option: `sort(list, list.length - 1)`

15. **Fill in the code to complete the following method for binary search.**
    - `public static int recursiveBinarySearch(int[] list, int key) { int low = 0; int high = list.length - 1; return __________________________; } public static int recursiveBinarySearch(int[] list, int key, int low, int high) { if (low > high) // The list has been exhausted without a match return -low - 1; // Return -insertion point - 1 int mid = (low + high) / 2; if (key < list[mid]) return recursiveBinarySearch(list, key, low, mid - 1); else if (key == list[mid]) return mid; else return recursiveBinarySearch(list, key, mid + 1, high); }`
    - Option: `recursiveBinarySearch(list, key, low, high)`

16. **How many times is the recursive moveDisks method invoked for 3 disks?**
    - Option: 7

17. **How many times is the recursive moveDisks method invoked for 4 disks?**
    - Option: 15

18. **Analyze the following two programs:**
    - A: `public class Test { public static void main(String[] args) { xMethod(5); } public static void xMethod(int length) { if (length > 1) { System.out.print((length - 1) + " "); xMethod(length - 1); } } }`
    - B: `public class Test { public static void main(String[] args) { xMethod(5); } public static void xMethod(int length) { while (length > 1) { System.out.print((length - 1) + " "); xMethod(length - 1); } } }`
    - Option: Program A produces the output 4 3 2 1 and Program B prints 4 3 2 1 1 1 .... 1 infinitely.

19. **In LiveExample 18.9, to draw three smaller triangles recursively, the program invokes:**
    - A. displayTriangles(order - 1, p1, p12, p31)
    - B. displayTriangles(order - 1, p12, p2, p23)
    - C. displayTriangles(order - 1, p31, p23, p3)

20. **Which of the following statements are true?**
    - A. Recursive methods run faster than non-recursive methods.
    - B. Recursive methods usually take more memory space than non-recursive methods.
    - C. A recursive method can always be replaced by a non-recursive method.
    - D. In some cases, however, using recursion enables you to give a natural, straightforward, simple solution to a program that would otherwise be difficult to solve.

... and so on for the remaining questions. Please let me know if you need further organization or have any specific queries related to these questions!

https://quizlet.com/419167280/chapter-18-recursion-flash-cards/

still need the 20 other questions , from teh previous links, the frst 20 questions ar ein the txt file, a total of 41 questions are in th e


i need to get hte html from thsi link
https://quizlet.com/162509469/cs-ii-chapter-18-quiz-flash-cards/


